#!/usr/bin/env -S deno run --allow-env --allow-read --allow-net
import { input, select, password } from "npm:@inquirer/prompts";

import { decodeHex } from "jsr:@std/encoding/hex";
import { program } from "npm:commander";
import * as tx from "./tx.ts";
import { SigningChoice, SiginigChoiceType } from "./signer.ts";

program
  .option(
    "-e, --endpoint <endpoint>",
    "WebSocket endpoint (e.g. wss://rpc.polkadot.io)"
  )
  .option(
    "--phrase <phrase>",
    "BIP‑39 mnemonic phrase (will supersede --seed if both supplied)"
  )
  .option("--seed <seed>", "Raw 0x‑prefixed hex seed (32‑byte)")
  .option(
    "--derive-path <path>",
    'Optional derivation path (e.g. "/polkadot/0")'
  )
  .option(
    "--key-file <file>",
    "A PKCS-8 encoded key pair, generated by the polkadot{.js} extension"
  )
  .option("--call-data <callData>")
  .parse();

type Cli = {
  endpoint?: string;
  phrase?: string;
  seed?: string;
  path?: string;
  keyFile?: string;
  callData?: string;
};

async function main() {
  try {
    const cli: Cli = program.opts();

    const endpoint = cli.endpoint
      ? cli.endpoint
      : await input({ message: "WebSocket endpoint URL?", required: true });
    const signingChoice = await resolveSigningChoice(cli);
    const callDataHex = cli.callData
      ? cli.callData
      : await input({ message: "Hex-encoded call data (0x…)?" });

    return tx.signAndSubmit(signingChoice, callDataHex, endpoint);
  } catch (e) {
    console.error((e as Error).message);
  }
}

async function resolveSigningChoice({
  phrase,
  path,
  seed,
  keyFile,
}: Cli): Promise<SigningChoice> {
  switch (
    ((!!phrase && 1) || 0) |
    ((!!seed && 2) || 0) |
    ((!!keyFile && 4) || 0)
  ) {
    case SiginigChoiceType.MNEMONIC: {
      // (Some(phrase), None, None)
      return {
        type: SiginigChoiceType.MNEMONIC,
        phrase: phrase!,
        derivePath: await askOptionalDerivePath(path),
      };
    }
    case SiginigChoiceType.SEED: {
      // (None, Some(hex_seed), None)
      return {
        type: SiginigChoiceType.SEED,
        seed: decodeHex(seed!),
      };
    }
    case SiginigChoiceType.FILE: {
      // (None, None, Some(file))
      return {
        type: SiginigChoiceType.FILE,
        file: (await import(keyFile!, { with: { type: "json" } })).default,
        passphrase: await password({ message: "Enter file passphrase:" }),
      };
    }
    default: {
      // _
      const choice = await select({
        message: "Choose signing material",
        choices: [
          { name: "Mnemonic phrase", value: SiginigChoiceType.MNEMONIC },
          { name: "Hex seed", value: SiginigChoiceType.SEED },
          { name: "polkadot{.js} secret file", value: SiginigChoiceType.FILE },
        ],
      });

      switch (choice) {
        case SiginigChoiceType.MNEMONIC: {
          return {
            type: choice,
            phrase: await input({ message: "Enter mnemonic phrase:" }),
            derivePath: await askOptionalDerivePath(),
          };
        }
        case SiginigChoiceType.SEED: {
          return {
            type: choice,
            seed: decodeHex(
              await input({ message: "Enter 0x‑prefixed hex seed:" })
            ),
          };
        }
        case SiginigChoiceType.FILE:
        default: {
          const file = await input({ message: "Enter file location:" });
          return {
            type: choice,
            file: (await import(file!, { with: { type: "json" } })).default,
            passphrase: await password({ message: "Enter file passphrase:" }),
          };
        }
      }
    }
  }
}

async function askOptionalDerivePath(
  maybeDerivePath?: string
): Promise<string | undefined> {
  if (maybeDerivePath) {
    return maybeDerivePath;
  }

  const path = await input({
    message: "Derivation path (leave blank to skip):",
  });

  return path.trim().length ? path : undefined;
}

main();
